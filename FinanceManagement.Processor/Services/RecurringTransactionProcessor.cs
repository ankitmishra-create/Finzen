using FinanceManagement.Core.Entities;
using FinanceManagement.Core.Enums;
using FinanceManagement.Infrastructure.Persistence.Repositories.InterfaceRepository;
using Microsoft.EntityFrameworkCore;
using Microsoft.Extensions.Logging;

namespace FinanceManagement.Processor.Services
{
    public class RecurringTransactionProcessor
    {
        private readonly IUnitOfWork _unitOfWork;
        private readonly ILogger<RecurringTransactionProcessor> _logger;

        public RecurringTransactionProcessor(IUnitOfWork unitOfWork, ILogger<RecurringTransactionProcessor> logger)
        {
            _unitOfWork = unitOfWork;
            _logger = logger;
        }

        public async Task ProcessRecurringTransactionsAsync()
        {
            try
            {
                _logger.LogInformation("Starting recurring transaction processing at {Time}", DateTime.UtcNow);

                // Use the service method to process due recurring transactions
                var generatedTransactions = await ProcessDueRecurringTransactionsAsync();

                _logger.LogInformation("Completed recurring transaction processing at {Time}. Generated {Count} transactions.",
                    DateTime.UtcNow, generatedTransactions.Count);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error occurred while processing recurring transactions");
                throw;
            }
        }

        private async Task<IEnumerable<RecurringTransactions>> GetDueRecurringTransactionsAsync()
        {
            var currentDate = DateTime.UtcNow.Date;

            return await _unitOfWork.RecurringTransaction.GetAllPopulatedAsync(
                rt => rt.IsActive &&
                      rt.NextTransactionDate.HasValue &&
                      rt.NextTransactionDate.Value.Date <= currentDate &&
                      (rt.EndDate == null || rt.EndDate.Value.Date >= currentDate),
                include: q => q.Include(rt => rt.User)
                              .Include(rt => rt.Category)
            );
        }

        private async Task ProcessSingleRecurringTransactionAsync(RecurringTransactions recurringTransaction)
        {
            try
            {
                _logger.LogInformation("Processing recurring transaction {RecurringTransactionId} for user {UserId}",
                    recurringTransaction.RecurringTransactionId, recurringTransaction.UserId);

                // Create a new transaction based on the recurring transaction template
                var newTransaction = await CreateNewTransactionFromRecurringAsync(recurringTransaction);

                // Update the recurring transaction with next execution date
                await UpdateRecurringTransactionNextExecutionAsync(recurringTransaction);

                _logger.LogInformation("Successfully processed recurring transaction {RecurringTransactionId}",
                    recurringTransaction.RecurringTransactionId);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error processing recurring transaction {RecurringTransactionId}",
                    recurringTransaction.RecurringTransactionId);
                throw;
            }
        }

        private async Task<Transaction> CreateNewTransactionFromRecurringAsync(RecurringTransactions recurringTransaction)
        {
            var currentDate = DateTime.UtcNow;

            var newTransaction = new Transaction
            {
                UserId = recurringTransaction.UserId,
                CategoryId = recurringTransaction.CategoryId,
                Amount = recurringTransaction.Amount,
                Description = recurringTransaction.Description,
                TransactionDate = currentDate,
                TransactionTerrority = recurringTransaction.TransactionTerrority,
                SelectedCurrency = recurringTransaction.TransactionCurrency,
                OriginalAmount = recurringTransaction.OriginalAmount,
                OriginalCurrency = recurringTransaction.OriginalCurrency,
                TransactionTimeLine = TransactionTimeLine.OneTime, // Generated transactions are one-time
                GeneratedFromRecurringId = recurringTransaction.RecurringTransactionId,
                IsAutoGenerated = true,
                CreatedAt = currentDate
            };

            await _unitOfWork.Transaction.AddAsync(newTransaction);
            return newTransaction;
        }

        private async Task UpdateRecurringTransactionNextExecutionAsync(RecurringTransactions recurringTransaction)
        {
            var currentDate = DateTime.UtcNow;
            var nextExecutionDate = CalculateNextExecutionDate(recurringTransaction.Frequency, currentDate);

            recurringTransaction.LastExecutedDate = currentDate;
            recurringTransaction.NextTransactionDate = nextExecutionDate;

            // Check if the recurring transaction has reached its end date
            if (recurringTransaction.EndDate.HasValue && nextExecutionDate > recurringTransaction.EndDate.Value)
            {
                recurringTransaction.IsActive = false;
                _logger.LogInformation("Recurring transaction {RecurringTransactionId} has reached its end date and is now inactive",
                    recurringTransaction.RecurringTransactionId);
            }

            _unitOfWork.RecurringTransaction.Update(recurringTransaction);
        }

        private DateTime CalculateNextExecutionDate(RecurrenceFrequency frequency, DateTime currentDate)
        {
            return frequency switch
            {
                RecurrenceFrequency.Daily => currentDate.AddDays(1),
                RecurrenceFrequency.Weekly => currentDate.AddDays(7),
                RecurrenceFrequency.Monthly => currentDate.AddMonths(1),
                RecurrenceFrequency.Quarterly => currentDate.AddMonths(3),
                RecurrenceFrequency.Yearly => currentDate.AddYears(1),
                _ => throw new ArgumentException($"Unsupported recurrence frequency: {frequency}")
            };
        }

        public async Task<int> GetPendingRecurringTransactionsCountAsync()
        {
            var currentDate = DateTime.UtcNow.Date;

            var dueTransactions = await _unitOfWork.RecurringTransaction.GetAllAsync(
                rt => rt.IsActive &&
                      rt.NextTransactionDate.HasValue &&
                      rt.NextTransactionDate.Value.Date <= currentDate &&
                      (rt.EndDate == null || rt.EndDate.Value.Date >= currentDate)
            );

            return dueTransactions.Count();
        }

        /// <summary>
        /// Processes due recurring transactions and generates new transactions
        /// </summary>
        public async Task<List<Transaction>> ProcessDueRecurringTransactionsAsync()
        {
            var generatedTransactions = new List<Transaction>();
            var currentDate = DateTime.UtcNow.Date;

            try
            {
                // Get all active recurring transactions that are due for execution
                var dueRecurringTransactions = await _unitOfWork.RecurringTransaction.GetAllPopulatedAsync(
                    rt => rt.IsActive &&
                          rt.NextTransactionDate.HasValue &&
                          rt.NextTransactionDate.Value.Date <= currentDate &&
                          (rt.EndDate == null || rt.EndDate.Value.Date >= currentDate),
                    include: q => q.Include(rt => rt.User)
                                  .Include(rt => rt.Category)
                );

                if (!dueRecurringTransactions.Any())
                {
                    _logger.LogInformation("No recurring transactions due for processing");
                    return generatedTransactions;
                }

                _logger.LogInformation("Found {Count} recurring transactions due for processing", dueRecurringTransactions.Count());

                foreach (var recurringTransaction in dueRecurringTransactions)
                {
                    // Create new transaction from template
                    var newTransaction = new Transaction
                    {
                        UserId = recurringTransaction.UserId,
                        CategoryId = recurringTransaction.CategoryId,
                        Amount = recurringTransaction.Amount,
                        Description = recurringTransaction.Description,
                        TransactionDate = DateTime.UtcNow,
                        TransactionTerrority = recurringTransaction.TransactionTerrority,
                        SelectedCurrency = recurringTransaction.TransactionCurrency,
                        OriginalAmount = recurringTransaction.OriginalAmount,
                        OriginalCurrency = recurringTransaction.OriginalCurrency,
                        TransactionTimeLine = TransactionTimeLine.OneTime, // Generated transactions are one-time
                        GeneratedFromRecurringId = recurringTransaction.RecurringTransactionId,
                        IsAutoGenerated = true
                    };

                    await _unitOfWork.Transaction.AddAsync(newTransaction);
                    generatedTransactions.Add(newTransaction);

                    // Update recurring transaction with next execution date
                    await UpdateRecurringTransactionNextExecutionAsync(recurringTransaction);
                }

                await _unitOfWork.SaveAsync();
                return generatedTransactions;
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error processing due recurring transactions");
                throw;
            }
        }
    }
}
