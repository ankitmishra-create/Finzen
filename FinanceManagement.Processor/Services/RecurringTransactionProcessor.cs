using FinanceManagement.Core.Entities;
using FinanceManagement.Core.Enums;
using FinanceManagement.Infrastructure.Interface;
using FinanceManagement.Infrastructure.Persistence.Repositories.InterfaceRepository;
using Microsoft.EntityFrameworkCore;

namespace FinanceManagement.Processor.Services
{
    public class RecurringTransactionProcessor
    {
        private readonly IUnitOfWork _unitOfWork;
        private readonly ICurrencyConversionService _currencyConversionService;

        public RecurringTransactionProcessor(IUnitOfWork unitOfWork, ICurrencyConversionService currencyConversionService)
        {
            _unitOfWork = unitOfWork;
            _currencyConversionService = currencyConversionService;
        }

        private async Task HandleInternationConversion(RecurringTransactions recurringTransactions)
        {
            var convertedAmount = await _currencyConversionService.GetConvertedRates(recurringTransactions.OriginalCurrency, recurringTransactions.TransactionCurrency);
            recurringTransactions.Amount = (decimal)(recurringTransactions.OriginalAmount * convertedAmount.conversion_rate);
        }

        private Transaction CreateTransaction(RecurringTransactions recurringTransaction)
        {
            if (recurringTransaction.TransactionTerrority == TransactionTerrority.International)
            {
                HandleInternationConversion(recurringTransaction);
            }
            Transaction transaction = new Transaction()
            {
                UserId = recurringTransaction.UserId,
                CategoryId = recurringTransaction.CategoryId,
                Amount = recurringTransaction.Amount,
                Description = recurringTransaction.Description,
                TransactionDate = DateTime.UtcNow,
                TransactionTerrority = recurringTransaction.TransactionTerrority,
                TransactionTimeLine = TransactionTimeLine.Recurring,
                RecurrenceFrequency = recurringTransaction.Frequency,
                SelectedCurrency = recurringTransaction.OriginalCurrency,
                OriginalAmount = recurringTransaction.OriginalAmount,
                OriginalCurrency = recurringTransaction.TransactionCurrency,
                GeneratedFromRecurringId = recurringTransaction.RecurringTransactionId,
                IsAutoGenerated = true
            };
            return transaction;
        }

        private void CalculateNextTransactionDate(RecurringTransactions recurringTransaction)
        {
            var nextTransactionDate = recurringTransaction.Frequency;
            switch ((RecurrenceFrequency)nextTransactionDate)
            {
                case RecurrenceFrequency.Daily:
                    recurringTransaction.NextTransactionDate = recurringTransaction.LastExecutedDate.Value.AddHours(24);
                    break;
                case RecurrenceFrequency.Weekly:
                    recurringTransaction.NextTransactionDate = recurringTransaction.LastExecutedDate.Value.AddDays(7);
                    break;
                case RecurrenceFrequency.Monthly:
                    recurringTransaction.NextTransactionDate = recurringTransaction.LastExecutedDate.Value.AddMonths(1);
                    break;
                case RecurrenceFrequency.Quarterly:
                    recurringTransaction.NextTransactionDate = recurringTransaction.LastExecutedDate.Value.AddMonths(3);
                    break;
                case RecurrenceFrequency.Yearly:
                    recurringTransaction.NextTransactionDate = recurringTransaction.LastExecutedDate.Value.AddYears(1);
                    break;
                default:
                    recurringTransaction.IsActive = false;
                    recurringTransaction.NextTransactionDate = null;
                    break;
            }

            if (recurringTransaction.EndDate.HasValue && recurringTransaction.NextTransactionDate.Value.Date > recurringTransaction.EndDate.Value.Date)
            {
                recurringTransaction.IsActive = false;
                recurringTransaction.NextTransactionDate = null;
            }
        }

        private void CalculateNextStepUpDate(RecurringTransactions recurringTransaction)
        {
            var nextTransactionDate = recurringTransaction.StepUpFrequeny;
            switch ((RecurrenceFrequency)nextTransactionDate)
            {
                case RecurrenceFrequency.Daily:
                    recurringTransaction.NextStepUpDate = recurringTransaction.LastStepUpDate.Value.AddHours(24);
                    break;
                case RecurrenceFrequency.Weekly:
                    recurringTransaction.NextStepUpDate = recurringTransaction.LastStepUpDate.Value.AddDays(7);
                    break;
                case RecurrenceFrequency.Monthly:
                    recurringTransaction.NextStepUpDate = recurringTransaction.LastStepUpDate.Value.AddMonths(1);
                    break;
                case RecurrenceFrequency.Quarterly:
                    recurringTransaction.NextStepUpDate = recurringTransaction.LastStepUpDate.Value.AddMonths(3);
                    break;
                case RecurrenceFrequency.Yearly:
                    recurringTransaction.NextStepUpDate = recurringTransaction.LastStepUpDate.Value.AddYears(1);
                    break;
                default:
                    recurringTransaction.IsActive = false;
                    recurringTransaction.NextTransactionDate = null;
                    recurringTransaction.IsStepUpTransaction = false;
                    recurringTransaction.NextStepUpDate = null;
                    break;
            }
        }

        private async Task<decimal> HandleInternationConversionStepUp(RecurringTransactions recurringTransactions)
        {
            var convertedAmount = await _currencyConversionService.GetConvertedRates(recurringTransactions.OriginalCurrency, recurringTransactions.TransactionCurrency);
            return (decimal)(recurringTransactions.StepUpAmount * convertedAmount.conversion_rate);
        }

        private async Task UpdateStepUp()
        {
            var todaysDate = DateTime.UtcNow.Date;
            var StepUpForTodays = await _unitOfWork.RecurringTransaction.GetAllAsync(t => t.IsActive && t.IsStepUpTransaction == true &&
            t.NextStepUpDate.HasValue && t.NextStepUpDate.Value.Date <= todaysDate &&
            t.EndDate.HasValue && t.EndDate.Value.Date >= todaysDate);

            int cnt = 0;
            foreach (var recurringTransaction in StepUpForTodays)
            {
                decimal convertedRates;
                if (recurringTransaction.TransactionTerrority == TransactionTerrority.International)
                {
                    convertedRates = await HandleInternationConversionStepUp(recurringTransaction);
                }
                else
                {
                    convertedRates = recurringTransaction.Amount;
                }

                if (recurringTransaction.StepUpAmount != null)
                {
                    recurringTransaction.Amount += convertedRates;
                    recurringTransaction.LastStepUpDate = DateTime.UtcNow;
                    CalculateNextStepUpDate(recurringTransaction);
                }
                else
                {
                    decimal updatedAmount = (decimal)((recurringTransaction.Amount * recurringTransaction.StepUpPercentage) / 100);
                    recurringTransaction.Amount = updatedAmount;
                    recurringTransaction.LastStepUpDate = DateTime.UtcNow;
                    CalculateNextStepUpDate(recurringTransaction);
                }
                cnt++;
            }
            if (cnt >= 1)
            {
                await _unitOfWork.SaveAsync();
            }
        }

        public async Task ProcessDueRecurringTransactionsAsync()
        {

            UpdateStepUp();

            var todaysDate = DateTime.UtcNow.Date;
            var pendingTransactions = await _unitOfWork.RecurringTransaction.GetAllPopulatedAsync(t => t.NextTransactionDate.HasValue
            && t.NextTransactionDate.Value.Date <= todaysDate
            && t.IsActive == true
            && (t.EndDate == null || t.EndDate.Value.Date >= todaysDate)
            , include: q => q.Include(c => c.Category));

            var changesCount = 0;
            foreach (var pendingTransaction in pendingTransactions)
            {
                var transaction = CreateTransaction(pendingTransaction);
                await _unitOfWork.Transaction.AddAsync(transaction);

                pendingTransaction.LastExecutedDate = DateTime.UtcNow;
                CalculateNextTransactionDate(pendingTransaction);
                _unitOfWork.RecurringTransaction.Update(pendingTransaction);
                changesCount++;
            }
            if (changesCount >= 1)
            {
                await _unitOfWork.SaveAsync();
            }
        }
    }
}
